# Node.js 정리 프로젝트

# Index
- [Node.js 배경](#NODE.JS-배경)
- [Node.js 란](#NODE.JS-란)
- [Node.js 구조](#NODE.JS-구조)
- [Node.js 특징](#NODE.JS-특징)
- [Node.js 장단점](#NODE.JS-장단점)
- [NPM](#Node-Packaged-Manager)
- [참가자](#참가자)

# Node.js 배경

[목록으로](#INDEX)

# Node.js 개념

웹 브라우저위에서 동작하던 JS가 서버를 제어할 수 있도록 해주는 **JS Run time**이다.이벤트 기반, non-blocking I/O 모델을 사용하여 가볍고 효율적이며 거대한 패키지 생태계인 npm를 통해 쉽게 모듈 확장이 가능하다.

NodeJs는 이벤트 기반으로 개발이 가능하며 Non-Blocking I/O를 지원하기 때문에 **비동기식 프로그래밍**이 가능하다. 이 때문에 I/O 부하가 심한 대규모 서비스를 개발하기 적합하다고 할 수 있다. 또한 자바스크립트의 표준라이브러리 프로젝트인 CommonJS의 스펙을 따르고 있어 일반적인 범용 언어으로 타 코드를 쉽게 사용할 수 있다.

[목록으로](#INDEX)

# Node.js 구조

[목록으로](#INDEX)

# Node.js 특징

## Single Thread

싱글 쓰레드를 가진 노드는 I/O 작업이 시작되면 I/O 작업 처리에 대한 응답을 기다리지 않고, **바로 다음 작업을 실행**해버린다. 대신 I/O 작업이 종료되면 이벤트를 발생시키고, 이 이벤트는 해당 프로세스의 이벤트 큐에 등록되게 된다. 노드로 개발된 프로세스는 이 이벤트 큐에 등록된 새로운 이벤트를 감지하여, 해당 이벤트 시 수행하여야 할 작업을 실행하는 로직을 가진다.

## V8 Engine 

V8 자바스크립트 엔진은 속도가 매우 빠르다는 장점과 더불어 구글이 해당 엔진을 개발하는 만큼 끊임없이 개선되고 발전할 것이다. 적극적인 개선과 발전으로 미래에 더 훌륭한 퍼포먼스를 가지게 될 것이라는 기대가 가능하다.

### V8이란 무엇인가?

V8은 오픈 소스이고 C++로 작성된 JavaScrpt 엔진이다. V8은 인터프리터(프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경)를 이용하는 대신 JavaScropt 코드를 좀더 효율적인 기계어 코드로 번역한다. V8은 SpiderMonkey나 Rhino 같은 많은 JavaScript 엔진처럼 JLT(Just-In-Time) 컴파일러를 적용하여 JavaScript 코드를 실행할 때 컴파일하여 기계어 코드로 만든다. V8의 가장 큰 차이는 바이트코드 또는 다른 중간 코드를 생성하지 않는 다는 것이다.

V8엔진은 다음과 같이 최적화된 코드를 생성한다.

### 인라이닝

![인라이닝](https://t1.daumcdn.net/cfile/tistory/9943DA425AA4EC1619)

첫 번째 최적화는 미리 가능한 많은 코드를 인라이닝(inlining) 하는것이다. 인라이닝은 호출 지점(함수가 호출된 곳의 코드 위치)을 호출된 함수의 내용으로 변환하는 과정이다. 

### 히든클래스 

V8은 히든클래스를 생성하여 프로퍼티 접근 시간을 줄일 수 있다.
다른 JavaScript Engine이 프로퍼티를 저장 하기 위해서 사전식 데이터 구조를 이용하지만, V8은 hidden class를 이용한다. 이 둘의 차이는 단순하게 이야기 해서 해싱과 포인터의 차이라고 할 수 있다.

V8은 객체에 프로퍼티를 추가할 때 히든 클래스를 생성하고, 히든 클래스에 프로퍼티의 정적인 위치를 저장함으로써 실제 데이터가 저장되어 있는 위치에 대한 Pointer를 제공한다. 
매번 프로퍼티를 추가할 때 마다 새로운 히든클래스를 생성하는 방식은 상당히 비효율 적이지만, 다음 번에 같은 객체를 생성할 때 이전에 생성했던 히든클래스를 재사용 함으로써 객체 생성 비용을 줄일 수 있다.


## Non-Blocking I/O

I/O 작업을 진행하는 동안 유저 프로세스의 작업을 중단시키지 않는다. non-blocking I/O의 경우 읽기/쓰기 이벤트가 발생하는 경우 데이터를 반환할 때 까지 기다리지 않고 다음 명령을 수행시킨다.  Non-blocking I/O 방식을 사용하면 외부에 I/O 작업을 하도록 요청한 후 즉시 다음 작업을 처리함으로써 시스템 자원을 더 효율적으로 사용할 수 있게된다. 그러나 I/O 작업이 완료된 이후에 처리해야하는 후속 작업이 있다면, I/O 작업이 완료될 때까지 기다려야 한다. 따라서 이 후속 작업이 프로세스를 멈추지 않도록 만들기 위해, I/O 작업이 완료된 이후 후속 작업을 이어서 진행할 수 있도록 별도의 약속([Polling](https://en.wikipedia.org/wiki/Asynchronous_I/O#Polling), [Callback function](https://en.wikipedia.org/wiki/Asynchronous_I/O#Callback_functions) 등)을 한다. 

## Event-Driven

사용자가 이벤트를 발생시켰을 때, 즉 입력장치로 데이터를 전송했을 때에만 작동한다. 발생한 이벤트에 대해서만 웹서버가 연결을 해주기 떄문에 자원을 최소화 할 수 있다.

> 대부분의 웹 서버는 이벤트가 발생할때까지 기다리면서 자원(대기시간/메모리)을 소비한다.

## Node의 모듈 시스템

[목록으로](#INDEX)

# Node.js의 장단점

## Node.js의 장점

## Node.js의 단점

 NodeJs는 자바스크립트와  싱글 쓰레드 모델에서 오는 장점이 있는 반면 여기서 오는 단점 역시 만만하지 않다. 기본적으로 싱글 쓰레드 모델이기 때문에, 하나의 작업 자체가 시간이 많이 걸리면, 전체 시스템의 성능이 아주 급격하게 떨어진다. 그래서, 가벼운 작업 위주로 개발이 되어야 하고, 자바스크립트에서 오는 문제점은 자바나 다른 언어에 비해서 명시성이 떨어지기 때문에, 코드의 가독성이 자바언어에 비해서 상대적으로 낮기 때문에 유지 보수가 어려워질 수 있다 또한 이벤트 Call back 을 형태를 기준으로 하기 때문에, 이러한 call back이 중첩될 경우 (이를 callback hell이라고 한다.) 코드의 가독성이 급격하게 떨어진다.

[목록으로](#INDEX)

# Node Packaged Manager

[목록으로](#INDEX)

# 참가자
1. 지현이
2. 최영훈
3. 
4. 
5. 
6. 
7. 
8. 

[목록으로](#INDEX)

### 출처

[nodejs란](https://asfirstalways.tistory.com/43 )

[non-blocking I/O](https://tech.peoplefund.co.kr/2017/08/02/non-blocking-asynchronous-concurrency.html )

[위키백과 NodeJs]( https://ko.wikipedia.org/wiki/Node.js )

[V8엔진](https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-v8-%EC%97%94%EC%A7%84%EC%9D%98-%EB%82%B4%EB%B6%80-%EC%B5%9C%EC%A0%81%ED%99%94%EB%90%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%8B%A4%EC%84%AF-%EA%B0%80%EC%A7%80-%ED%8C%81-6c6f9832c1d9)